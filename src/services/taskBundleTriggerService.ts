/**
 * Task Bundle Trigger Service
 * Handles automated task creation from task bundles on various triggers
 */

import { TaskBundleRepository, TaskBundleWithItems } from '@/data/repositories/TaskBundleRepository';
import { StorageManager } from '@/data/StorageManager';
import { tasksService, CreateTaskData } from './tasksService';
import { persistenceService } from './persistenceService';
import { GSTStage, GSTNoticeType, ClientTier } from '../../config/appConfig';
import { toast } from 'sonner';
import type { AppAction } from '@/contexts/AppStateContext';

interface CaseData {
  id: string;
  caseNumber: string;
  clientId: string;
  assignedToId: string;
  assignedToName: string;
  currentStage: string;
  noticeType?: GSTNoticeType;
  clientTier?: ClientTier;
}

interface BundleCreationFootprint {
  caseId: string;
  bundleId: string;
  stage: string;
  trigger: string;
  createdAt: string;
  taskIds: string[];
}

interface BundleAutomationResult {
  createdTasks: BundleCreationFootprint[];
  skippedBundles: string[];
  totalTasksCreated: number;
}

class TaskBundleTriggerService {
  private repository: TaskBundleRepository | null = null;
  private readonly FOOTPRINTS_KEY = 'bundle-creation-footprints';

  private async getRepository(): Promise<TaskBundleRepository> {
    if (!this.repository) {
      await StorageManager.getInstance().initialize();
      this.repository = StorageManager.getInstance().getTaskBundleRepository();
      if (!this.repository) {
        throw new Error('TaskBundleRepository not available');
      }
    }
    return this.repository;
  }

  async triggerTaskBundles(
    caseData: CaseData,
    trigger: string,
    stage: GSTStage,
    dispatch?: React.Dispatch<AppAction>
  ): Promise<BundleAutomationResult> {
    console.log(`[BundleTrigger] Processing bundles for trigger: ${trigger}, stage: ${stage}`);
    
    try {
      const repository = await this.getRepository();
      const applicableBundles = await repository.getBundlesByTrigger(trigger, stage);
      
      console.log(`[BundleTrigger] Found ${applicableBundles.length} applicable bundle(s):`, {
        trigger,
        stage,
        bundles: applicableBundles.map(b => ({
          id: b.id,
          name: b.name,
          trigger: b.trigger,
          stage_code: b.stage_code,
          is_active: b.is_active,
          itemCount: b.items?.length || 0
        }))
      });
      
      const createdTasks: BundleCreationFootprint[] = [];
      const skippedBundles: string[] = [];
      let totalTasksCreated = 0;

      for (const bundle of applicableBundles) {
        const bundleResult = await this.processBundleIdempotently(
          caseData, 
          bundle, 
          stage, 
          trigger, 
          dispatch
        );
        
        if (bundleResult) {
          createdTasks.push(bundleResult);
          totalTasksCreated += bundleResult.taskIds.length;
        } else {
          skippedBundles.push(bundle.id);
        }
      }

      if (totalTasksCreated > 0) {
        toast.success(`Created ${totalTasksCreated} task(s) from ${createdTasks.length} bundle(s)`);
      }

      return {
        createdTasks,
        skippedBundles,
        totalTasksCreated
      };
    } catch (error) {
      console.error('[BundleTrigger] Failed to process task bundles:', error);
      throw error;
    }
  }

  private async processBundleIdempotently(
    caseData: CaseData,
    bundle: TaskBundleWithItems,
    stage: GSTStage,
    trigger: string,
    dispatch?: React.Dispatch<AppAction>
  ): Promise<BundleCreationFootprint | null> {
    const footprints = await this.getFootprints();
    
    // Check if this bundle was already processed for this case/stage/trigger
    const existingFootprint = footprints.find(f => 
      f.caseId === caseData.id && 
      f.bundleId === bundle.id && 
      f.stage === stage &&
      f.trigger === trigger
    );

    if (existingFootprint) {
      console.log(`[BundleTrigger] Skipping duplicate bundle: ${bundle.name}`);
      return null;
    }

    // Evaluate bundle conditions
    if (!this.evaluateBundleConditions(bundle, caseData)) {
      console.log(`[BundleTrigger] Bundle conditions not met: ${bundle.name}`);
      return null;
    }

    const createdTaskIds: string[] = [];

    // Create tasks from bundle items
    for (const item of bundle.items) {
      try {
        // Use tasksService with bundleId and isAutoGenerated flags
        const task = await tasksService.create({
          title: item.title,
          description: `${item.description || ''}\n\n[Auto-created from bundle: ${bundle.name}]`,
          caseId: caseData.id,
          clientId: caseData.clientId,
          caseNumber: caseData.caseNumber,
          stage: stage,
          priority: item.priority as any,
          status: 'Not Started',
          assignedToId: caseData.assignedToId,
          assignedToName: caseData.assignedToName,
          dueDate: this.calculateDueDate(item.estimated_hours || 8),
          estimatedHours: item.estimated_hours || 8,
          isAutoGenerated: true,
          bundleId: bundle.id
        } as any, dispatch);

        createdTaskIds.push(task.id);
        
      } catch (error) {
        console.error(`[BundleTrigger] Failed to create task ${item.title}:`, error);
      }
    }

    if (createdTaskIds.length > 0) {
      const footprint: BundleCreationFootprint = {
        caseId: caseData.id,
        bundleId: bundle.id,
        stage: stage,
        trigger: trigger,
        createdAt: new Date().toISOString(),
        taskIds: createdTaskIds
      };

      footprints.push(footprint);
      await this.saveFootprints(footprints);

      return footprint;
    }

    return null;
  }

  private evaluateBundleConditions(bundle: TaskBundleWithItems, caseData: CaseData): boolean {
    // Normalize stage for comparison - maps various formats to canonical names
    const normalizeStageForComparison = (stage: string | undefined): string => {
      if (!stage) return '';
      const normalized = stage.trim().toLowerCase();
      
      // Map common variants to canonical names
      if (normalized.includes('assessment') || normalized.includes('drc-01')) return 'assessment';
      if (normalized.includes('adjudication') || normalized.includes('scn')) return 'adjudication';
      if (normalized.includes('first') && normalized.includes('appeal')) return 'first appeal';
      if (normalized.includes('tribunal')) return 'tribunal';
      if (normalized.includes('high') && normalized.includes('court')) return 'high court';
      if (normalized.includes('supreme')) return 'supreme court';
      
      return normalized.replace(/\s+/g, '-');
    };
    
    const bundleStage = normalizeStageForComparison(bundle.stage_code);
    const caseStage = normalizeStageForComparison(caseData.currentStage);
    
    console.log(`[BundleTrigger] Evaluating conditions for "${bundle.name}":`, {
      bundleStage,
      caseStage,
      bundleStageRaw: bundle.stage_code,
      caseStageRaw: caseData.currentStage
    });
    
    // If bundle has no stage_code or "Any Stage", it applies to all stages
    if (!bundle.stage_code || bundle.stage_code === 'Any Stage' || bundle.stage_code.trim() === '') {
      console.log(`[BundleTrigger] Bundle applies to any stage`);
      return true;
    }
    
    // Check if normalized stages match
    if (bundleStage === caseStage) {
      console.log(`[BundleTrigger] Stage match - bundle: ${bundleStage}, case: ${caseStage}`);
      return true;
    }
    
    // Check if raw stage_code matches (exact match)
    if (bundle.stage_code === caseData.currentStage) {
      console.log(`[BundleTrigger] Exact stage match`);
      return true;
    }

    console.log(`[BundleTrigger] Stage mismatch - bundle: ${bundleStage}, case: ${caseStage}`);
    return false;
  }

  private calculateDueDate(estimatedHours: number): string {
    const workDaysToAdd = Math.ceil(estimatedHours / 8);
    const dueDate = new Date();
    
    let addedDays = 0;
    while (addedDays < workDaysToAdd) {
      dueDate.setDate(dueDate.getDate() + 1);
      if (dueDate.getDay() !== 0 && dueDate.getDay() !== 6) {
        addedDays++;
      }
    }
    
    return dueDate.toISOString().split('T')[0];
  }

  private async getFootprints(): Promise<BundleCreationFootprint[]> {
    // Stubbed: Supabase-only mode - no IndexedDB footprint storage
    return [];
  }

  private async saveFootprints(footprints: BundleCreationFootprint[]): Promise<void> {
    // Stubbed: Supabase-only mode - no IndexedDB footprint storage
    console.warn('[TaskBundleTriggerService] Footprint saving not available in Supabase-only mode');
  }

  // Get automation history for analytics
  async getAutomationHistory(caseId?: string): Promise<BundleCreationFootprint[]> {
    const footprints = await this.getFootprints();
    return caseId ? footprints.filter(f => f.caseId === caseId) : footprints;
  }

  // Clear automation history (for testing/cleanup)
  async clearAutomationHistory(): Promise<void> {
    // Stubbed: Supabase-only mode
    console.warn('[TaskBundleTriggerService] Clear history not available in Supabase-only mode');
  }
}

export const taskBundleTriggerService = new TaskBundleTriggerService();