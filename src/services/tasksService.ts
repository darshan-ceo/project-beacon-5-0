import { Task } from '@/contexts/AppStateContext';
import { storageManager } from '@/data/StorageManager';
import { toast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { auditService } from '@/services/auditService';
import { notificationSystemService } from '@/services/notificationSystemService';

export interface CreateTaskData {
  title: string;
  description: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  status: 'Not Started' | 'In Progress' | 'Review' | 'Completed' | 'Overdue';
  assignedToId: string;
  assignedToName: string;
  assignedById?: string;
  assignedByName?: string;
  dueDate: string;
  estimatedHours: number;
  tags?: string[];
}

export interface UpdateTaskData extends Partial<CreateTaskData> {
  id: string;
}

class TasksService {
  /**
   * Create a new task with persistence and dispatch
   */
  async create(taskData: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();
      
      // Build complete task object
      const newTask: Task = {
        id: '', // Server will generate UUID
        title: taskData.title || '',
        description: taskData.description || '',
        caseId: taskData.caseId || '',
        clientId: taskData.clientId || '',
        caseNumber: taskData.caseNumber || '',
        stage: taskData.stage || '',
        priority: taskData.priority || 'Medium',
        status: taskData.status || 'Not Started',
        assignedToId: taskData.assignedToId || '',
        assignedToName: taskData.assignedToName || '',
        assignedById: taskData.assignedById || '',
        assignedByName: taskData.assignedByName || '',
        createdDate: new Date().toISOString().split('T')[0],
        dueDate: taskData.dueDate || '',
        estimatedHours: taskData.estimatedHours || 8,
        isAutoGenerated: (taskData as any).isAutoGenerated ?? false,
        bundleId: (taskData as any).bundleId || undefined,
        escalationLevel: 0,
        timezone: 'Asia/Kolkata',
        dueDateValidated: true,
        audit_trail: {
          created_by: 'system',
          created_at: new Date().toISOString(),
          updated_by: 'system',
          updated_at: new Date().toISOString(),
          change_log: []
        }
      };

      // Persist to Supabase
      const created = await storage.create('tasks', {
        title: newTask.title,
        description: newTask.description,
        case_id: newTask.caseId,
        client_id: newTask.clientId,
        case_number: newTask.caseNumber,
        stage: newTask.stage,
        priority: newTask.priority,
        status: newTask.status,
        assigned_to: newTask.assignedToId,
        due_date: newTask.dueDate,
        estimated_hours: newTask.estimatedHours,
        is_auto_generated: newTask.isAutoGenerated,
        bundle_id: newTask.bundleId || null,
      } as any);

      // Get server-generated UUID
      const persistedTask = { ...newTask, id: created.id };

      // Dispatch to context
      dispatch({ type: 'ADD_TASK', payload: persistedTask });

      // Show success toast
      toast({
        title: "Task Created",
        description: `Task "${persistedTask.title}" has been created successfully.`,
      });

      // Log audit event for task creation
      try {
        const { data: { user } } = await supabase.auth.getUser();
        const { data: profile } = await supabase.from('profiles').select('tenant_id').eq('id', user?.id).single();
        if (user && profile?.tenant_id) {
          await auditService.log('create_task', profile.tenant_id, {
            userId: user.id,
            entityType: 'task',
            entityId: persistedTask.id,
            details: { 
              title: persistedTask.title,
              caseId: persistedTask.caseId,
              assignedTo: persistedTask.assignedToName,
              dueDate: persistedTask.dueDate,
              priority: persistedTask.priority
            }
          });
        }
      } catch (auditError) {
        console.warn('Failed to log audit event for task creation:', auditError);
      }

      // Send notification to assignee (if different from current user)
      try {
        const { data: { user: currentUser } } = await supabase.auth.getUser();
        const isDev = import.meta.env.DEV;
        
        // Dev logging: show assignment and notification decision
        if (isDev) {
          console.log('[TasksService] Notification check:', {
            taskId: persistedTask.id,
            taskTitle: persistedTask.title,
            currentUserId: currentUser?.id,
            assignedToId: persistedTask.assignedToId,
            willNotify: persistedTask.assignedToId && persistedTask.assignedToId !== currentUser?.id
          });
        }
        
        if (persistedTask.assignedToId && persistedTask.assignedToId !== currentUser?.id) {
          const result = await notificationSystemService.createNotification(
            'task_assigned',
            `New Task: ${persistedTask.title}`,
            `You have been assigned a new task${persistedTask.caseNumber ? ` for case ${persistedTask.caseNumber}` : ''}. ${persistedTask.dueDate ? `Due: ${persistedTask.dueDate}` : ''}`,
            persistedTask.assignedToId,
            {
              relatedEntityType: 'task',
              relatedEntityId: persistedTask.id,
              channels: ['in_app'],
              metadata: { 
                priority: persistedTask.priority, 
                caseId: persistedTask.caseId,
                assignedBy: currentUser?.id
              }
            }
          );
          
          if (result) {
            console.log('[TasksService] Notification sent to assignee:', persistedTask.assignedToId, 'notificationId:', result.id);
          } else {
            console.warn('[TasksService] Notification creation returned null for assignee:', persistedTask.assignedToId);
          }
        } else if (isDev && !persistedTask.assignedToId) {
          console.log('[TasksService] Notification skipped: No assignee specified');
        } else if (isDev && persistedTask.assignedToId === currentUser?.id) {
          console.log('[TasksService] Notification skipped: Self-assignment (creator is assignee)');
        }
      } catch (notifError) {
        console.warn('Failed to send notification for task assignment:', notifError);
      }

      return persistedTask;
    } catch (error) {
      console.error('Failed to create task:', error);
      toast({
        title: "Error",
        description: "Failed to create task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Update an existing task
   */
  async update(taskId: string, updates: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();

      // Fetch existing task to merge with updates
      const existing = await storage.getById<any>('tasks', taskId);
      if (!existing) {
        throw new Error('Task not found');
      }

      // Prepare updates for Supabase
      const supabaseUpdates: any = {
        updated_at: new Date().toISOString(),
      };
      if (updates.title !== undefined) supabaseUpdates.title = updates.title;
      if (updates.description !== undefined) supabaseUpdates.description = updates.description;
      if (updates.priority !== undefined) supabaseUpdates.priority = updates.priority;
      if (updates.status !== undefined) supabaseUpdates.status = updates.status;
      if (updates.assignedToId !== undefined) supabaseUpdates.assigned_to = updates.assignedToId;
      if (updates.assignedToName !== undefined) supabaseUpdates.assigned_to_name = updates.assignedToName;
      if (updates.dueDate !== undefined) supabaseUpdates.due_date = updates.dueDate;
      if (updates.estimatedHours !== undefined) supabaseUpdates.estimated_hours = updates.estimatedHours;
      if (updates.completedDate !== undefined) supabaseUpdates.completed_at = updates.completedDate;
      if (updates.stage !== undefined) supabaseUpdates.stage = updates.stage;
      if (updates.caseId !== undefined) supabaseUpdates.case_id = updates.caseId;
      if (updates.clientId !== undefined) supabaseUpdates.client_id = updates.clientId;

      // Persist to Supabase
      await storage.update('tasks', taskId, supabaseUpdates);

      // Build full updated task by merging existing with updates
      const fullUpdatedTask: Task = {
        id: taskId,
        title: updates.title ?? existing.title,
        description: updates.description ?? existing.description,
        caseId: updates.caseId ?? existing.case_id,
        clientId: updates.clientId ?? existing.client_id,
        caseNumber: updates.caseNumber ?? existing.case_number ?? '',
        stage: updates.stage ?? existing.stage ?? '',
        priority: updates.priority ?? existing.priority ?? 'Medium',
        status: updates.status ?? existing.status ?? 'Not Started',
        assignedToId: updates.assignedToId ?? existing.assigned_to ?? '',
        assignedToName: updates.assignedToName ?? existing.assigned_to_name ?? '',
        assignedById: updates.assignedById ?? existing.assigned_by ?? '',
        assignedByName: updates.assignedByName ?? existing.assigned_by_name ?? '',
        createdDate: existing.created_at ? existing.created_at.split('T')[0] : '',
        dueDate: updates.dueDate ?? existing.due_date ?? '',
        completedDate: updates.completedDate ?? existing.completed_at,
        estimatedHours: updates.estimatedHours ?? existing.estimated_hours ?? 8,
        actualHours: updates.actualHours ?? existing.actual_hours,
        isAutoGenerated: existing.is_auto_generated ?? false,
        bundleId: existing.bundle_id,
        escalationLevel: existing.escalation_level ?? 0,
        timezone: existing.timezone ?? 'Asia/Kolkata',
        dueDateValidated: true,
        audit_trail: {
          created_by: existing.created_by ?? 'system',
          created_at: existing.created_at ?? new Date().toISOString(),
          updated_by: 'system',
          updated_at: new Date().toISOString(),
          change_log: []
        }
      };

      // Dispatch full merged task to context for immediate UI update
      dispatch({ type: 'UPDATE_TASK', payload: fullUpdatedTask });

      // Show success toast
      toast({
        title: "Task Updated",
        description: `Task "${fullUpdatedTask.title}" has been updated successfully.`,
      });

      // Log audit event for task update
      try {
        const { data: { user } } = await supabase.auth.getUser();
        const { data: profile } = await supabase.from('profiles').select('tenant_id').eq('id', user?.id).single();
        if (user && profile?.tenant_id) {
          await auditService.log('update_task', profile.tenant_id, {
            userId: user.id,
            entityType: 'task',
            entityId: taskId,
            details: { 
              title: fullUpdatedTask.title,
              updatedFields: Object.keys(updates),
              status: fullUpdatedTask.status
            }
          });
        }
      } catch (auditError) {
        console.warn('Failed to log audit event for task update:', auditError);
      }

      return fullUpdatedTask;
    } catch (error) {
      console.error('Failed to update task:', error);
      toast({
        title: "Error",
        description: "Failed to update task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Delete a task with Supabase response validation
   * Prevents optimistic UI updates when RLS denies the operation
   */
  async delete(taskId: string, dispatch: any): Promise<void> {
    try {
      // Get task details before deletion for audit
      const { data: taskToDelete, error: fetchError } = await supabase
        .from('tasks')
        .select('*')
        .eq('id', taskId)
        .maybeSingle();

      if (fetchError) {
        console.error('Failed to fetch task before deletion:', fetchError);
      }

      // Attempt delete via Supabase directly to get proper error handling
      const { error: deleteError, count } = await supabase
        .from('tasks')
        .delete()
        .eq('id', taskId)
        .select();

      // Check for RLS denial or other errors
      if (deleteError) {
        // Check if it's a permission/RLS error
        if (deleteError.code === '42501' || 
            deleteError.message?.includes('policy') ||
            deleteError.message?.includes('permission')) {
          toast({
            title: "Permission Denied",
            description: "You don't have permission to delete this task.",
            variant: "destructive"
          });
          throw new Error('Permission denied by database policy');
        }
        
        // Other database error
        console.error('Failed to delete task:', deleteError);
        toast({
          title: "Error",
          description: "Failed to delete task. Please try again.",
          variant: "destructive"
        });
        throw deleteError;
      }

      // Only dispatch to UI if Supabase confirmed the deletion
      dispatch({ type: 'DELETE_TASK', payload: taskId });

      // Show success toast
      toast({
        title: "Task Deleted",
        description: "Task has been deleted successfully.",
      });

      // Log audit event for task deletion
      try {
        const { data: { user } } = await supabase.auth.getUser();
        const { data: profile } = await supabase.from('profiles').select('tenant_id').eq('id', user?.id).single();
        if (user && profile?.tenant_id) {
          await auditService.log('delete_task', profile.tenant_id, {
            userId: user.id,
            entityType: 'task',
            entityId: taskId,
            details: { 
              title: taskToDelete?.title || 'Unknown',
              caseId: taskToDelete?.case_id
            }
          });
        }
      } catch (auditError) {
        console.warn('Failed to log audit event for task deletion:', auditError);
      }
    } catch (error) {
      // Re-throw to let caller handle
      throw error;
    }
  }

  /**
   * Bulk update status for multiple tasks
   */
  async bulkUpdateStatus(taskIds: string[], status: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { status: status as any }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update status for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk update priority for multiple tasks
   */
  async bulkUpdatePriority(taskIds: string[], priority: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { priority: priority as any }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update priority for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk reassign tasks to a new employee
   */
  async bulkReassign(taskIds: string[], assigneeId: string, assigneeName: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { assignedToId: assigneeId, assignedToName: assigneeName }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to reassign task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk update due date for multiple tasks
   */
  async bulkUpdateDueDate(taskIds: string[], dueDate: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { dueDate }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update due date for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk add comment to multiple tasks (stores in description or notes)
   */
  async bulkAddComment(taskIds: string[], comment: string, userName: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;
    const timestamp = new Date().toISOString();
    const formattedComment = `\n\n[${userName} - ${timestamp.split('T')[0]}]: ${comment}`;
    const storage = storageManager.getStorage();

    for (const taskId of taskIds) {
      try {
        const task = await storage.getById('tasks', taskId) as any;
        if (task) {
          const newDescription = (task.description || '') + formattedComment;
          await this.update(taskId, { description: newDescription }, dispatch);
          success++;
        } else {
          failed++;
        }
      } catch (error) {
        console.error(`Failed to add comment to task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk delete multiple tasks
   */
  async bulkDelete(taskIds: string[], dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.delete(taskId, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to delete task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * List all tasks from Supabase
   */
  async list(): Promise<Task[]> {
    try {
      const storage = storageManager.getStorage();
      const tasks = await storage.getAll('tasks');
      
      // Basic mapping - display-only fields will be populated by UI layer
      return tasks.map((t: any) => ({
        id: t.id,
        title: t.title,
        description: t.description,
        status: t.status,
        priority: t.priority,
        caseId: t.case_id,
        clientId: t.client_id,
        assignedToId: t.assigned_to,
        assignedById: t.assigned_by,
        dueDate: t.due_date,
        completedDate: t.completed_at,
        estimatedHours: t.estimated_hours,
        actualHours: t.actual_hours,
        stage: t.stage,
        isAutoGenerated: t.is_auto_generated,
        bundleId: t.bundle_id,
        createdDate: t.created_at,
        lastModified: t.updated_at,
      } as unknown as Task));
    } catch (error) {
      console.error('Failed to get task:', error);
      throw error;
    }
  }
}

export const tasksService = new TasksService();
