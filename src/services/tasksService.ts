import { Task } from '@/contexts/AppStateContext';

export interface CreateTaskData {
  title: string;
  description: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  status: 'Not Started' | 'In Progress' | 'Review' | 'Completed' | 'Overdue';
  assignedToId: string;
  assignedToName: string;
  assignedById: string;
  assignedByName: string;
  dueDate: string;
  estimatedHours: number;
  tags?: string[];
}

export interface UpdateTaskData extends Partial<CreateTaskData> {
  id: string;
}

class TasksService {
  private tasks: Task[] = [];

  async create(data: CreateTaskData): Promise<Task> {
    // FIXED: Use UUID instead of timestamp
    const { generateId } = await import('@/data/db');
    const newTask: Task = {
      id: generateId(),
      ...data,
      createdDate: new Date().toISOString().split('T')[0],
      isAutoGenerated: false,
      escalationLevel: 0
    };

    // FIXED: Persist to storage
    const { storageManager } = await import('@/data/StorageManager');
    const { changeTracker } = await import('./changeTracker');
    const { ENTITY_TYPES } = await import('@/constants/StorageKeys');
    
    try {
      const storage = storageManager.getStorage();
      await storage.create('tasks', {
        id: newTask.id,
        case_id: newTask.caseId,
        assigned_to: newTask.assignedToId,
        due_date: newTask.dueDate ? new Date(newTask.dueDate) : undefined,
        status: newTask.status,
        priority: newTask.priority,
        title: newTask.title,
        description: newTask.description,
        created_at: new Date(),
        updated_at: new Date(),
        is_auto_generated: newTask.isAutoGenerated,
        estimated_hours: newTask.estimatedHours,
      });

      changeTracker.markDirty(ENTITY_TYPES.TASK, newTask.id, 'create');
      changeTracker.logChange(ENTITY_TYPES.TASK, newTask.id, 'create');
    } catch (storageError) {
      console.error('Failed to persist task to storage:', storageError);
    }

    this.tasks.push(newTask);
    return newTask;
  }

  async update(data: UpdateTaskData): Promise<Task> {
    const index = this.tasks.findIndex(t => t.id === data.id);
    if (index === -1) {
      throw new Error('Task not found');
    }

    const updatedTask = {
      ...this.tasks[index],
      ...data
    };

    this.tasks[index] = updatedTask;
    return updatedTask;
  }

  async updateStatus(id: string, status: Task['status']): Promise<Task> {
    return this.update({ id, status });
  }

  async get(id: string): Promise<Task | null> {
    return this.tasks.find(t => t.id === id) || null;
  }

  async delete(id: string): Promise<void> {
    const index = this.tasks.findIndex(t => t.id === id);
    if (index !== -1) {
      this.tasks.splice(index, 1);
    }
  }

  async list(): Promise<Task[]> {
    return [...this.tasks];
  }

  async getByCase(caseId: string): Promise<Task[]> {
    return this.tasks.filter(t => t.caseId === caseId);
  }

  async getByAssignee(assignedToId: string): Promise<Task[]> {
    return this.tasks.filter(t => t.assignedToId === assignedToId);
  }
}

export const tasksService = new TasksService();