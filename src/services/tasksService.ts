import { Task } from '@/contexts/AppStateContext';
import { storageManager } from '@/data/StorageManager';
import { toast } from '@/hooks/use-toast';

export interface CreateTaskData {
  title: string;
  description: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  status: 'Not Started' | 'In Progress' | 'Review' | 'Completed' | 'Overdue';
  assignedToId: string;
  assignedToName: string;
  assignedById?: string;
  assignedByName?: string;
  dueDate: string;
  estimatedHours: number;
  tags?: string[];
}

export interface UpdateTaskData extends Partial<CreateTaskData> {
  id: string;
}

class TasksService {
  /**
   * Create a new task with persistence and dispatch
   */
  async create(taskData: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();
      
      // Build complete task object
      const newTask: Task = {
        id: '', // Server will generate UUID
        title: taskData.title || '',
        description: taskData.description || '',
        caseId: taskData.caseId || '',
        clientId: taskData.clientId || '',
        caseNumber: taskData.caseNumber || '',
        stage: taskData.stage || '',
        priority: taskData.priority || 'Medium',
        status: taskData.status || 'Not Started',
        assignedToId: taskData.assignedToId || '',
        assignedToName: taskData.assignedToName || '',
        assignedById: taskData.assignedById || '',
        assignedByName: taskData.assignedByName || '',
        createdDate: new Date().toISOString().split('T')[0],
        dueDate: taskData.dueDate || '',
        estimatedHours: taskData.estimatedHours || 8,
        isAutoGenerated: false,
        escalationLevel: 0,
        timezone: 'Asia/Kolkata',
        dueDateValidated: true,
        audit_trail: {
          created_by: 'system',
          created_at: new Date().toISOString(),
          updated_by: 'system',
          updated_at: new Date().toISOString(),
          change_log: []
        }
      };

      // Persist to Supabase
      const created = await storage.create('tasks', {
        title: newTask.title,
        description: newTask.description,
        case_id: newTask.caseId,
        client_id: newTask.clientId,
        case_number: newTask.caseNumber,
        stage: newTask.stage,
        priority: newTask.priority,
        status: newTask.status,
        assigned_to: newTask.assignedToId,
        due_date: newTask.dueDate,
        estimated_hours: newTask.estimatedHours,
        is_auto_generated: newTask.isAutoGenerated,
      } as any);

      // Get server-generated UUID
      const persistedTask = { ...newTask, id: created.id };

      // Dispatch to context
      dispatch({ type: 'ADD_TASK', payload: persistedTask });

      // Show success toast
      toast({
        title: "Task Created",
        description: `Task "${persistedTask.title}" has been created successfully.`,
      });

      return persistedTask;
    } catch (error) {
      console.error('Failed to create task:', error);
      toast({
        title: "Error",
        description: "Failed to create task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Update an existing task
   */
  async update(taskId: string, updates: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();

      // Persist to Supabase
      await storage.update('tasks', taskId, {
        ...(updates.title && { title: updates.title }),
        ...(updates.description && { description: updates.description }),
        ...(updates.priority && { priority: updates.priority }),
        ...(updates.status && { status: updates.status }),
        ...(updates.assignedToId && { assigned_to: updates.assignedToId }),
        ...(updates.dueDate && { due_date: updates.dueDate }),
        ...(updates.estimatedHours && { estimated_hours: updates.estimatedHours }),
        updated_at: new Date().toISOString(),
      } as any);

      // Build updated task
      const updatedTask = { ...updates, id: taskId } as Task;

      // Dispatch to context
      dispatch({ type: 'UPDATE_TASK', payload: updatedTask });

      // Show success toast
      toast({
        title: "Task Updated",
        description: `Task "${updates.title || taskId}" has been updated successfully.`,
      });

      return updatedTask;
    } catch (error) {
      console.error('Failed to update task:', error);
      toast({
        title: "Error",
        description: "Failed to update task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Delete a task
   */
  async delete(taskId: string, dispatch: any): Promise<void> {
    try {
      const storage = storageManager.getStorage();

      // Delete from Supabase
      await storage.delete('tasks', taskId);

      // Dispatch to context
      dispatch({ type: 'DELETE_TASK', payload: taskId });

      // Show success toast
      toast({
        title: "Task Deleted",
        description: "Task has been deleted successfully.",
      });
    } catch (error) {
      console.error('Failed to delete task:', error);
      toast({
        title: "Error",
        description: "Failed to delete task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * List all tasks from Supabase
   */
  async list(): Promise<Task[]> {
    try {
      const storage = storageManager.getStorage();
      const tasks = await storage.getAll('tasks');
      
      // Basic mapping - display-only fields will be populated by UI layer
      return tasks.map((t: any) => ({
        id: t.id,
        title: t.title,
        description: t.description,
        status: t.status,
        priority: t.priority,
        caseId: t.case_id,
        clientId: t.client_id,
        assignedToId: t.assigned_to,
        assignedById: t.assigned_by,
        dueDate: t.due_date,
        completedDate: t.completed_at,
        estimatedHours: t.estimated_hours,
        actualHours: t.actual_hours,
        stage: t.stage,
        isAutoGenerated: t.is_auto_generated,
        bundleId: t.bundle_id,
        createdDate: t.created_at,
        lastModified: t.updated_at,
      } as unknown as Task));
    } catch (error) {
      console.error('Failed to list tasks:', error);
      throw error;
    }
  }

  /**
   * Get single task by ID
   */
  async getById(taskId: string): Promise<Task | null> {
    try {
      const storage = storageManager.getStorage();
      const task = await storage.getById('tasks', taskId) as any;
      
      if (!task) return null;
      
      // Basic mapping - display-only fields will be populated by UI layer
      return {
        id: task.id,
        title: task.title,
        description: task.description,
        status: task.status,
        priority: task.priority,
        caseId: task.case_id,
        clientId: task.client_id,
        assignedToId: task.assigned_to,
        assignedById: task.assigned_by,
        dueDate: task.due_date,
        completedDate: task.completed_at,
        estimatedHours: task.estimated_hours,
        actualHours: task.actual_hours,
        stage: task.stage,
        isAutoGenerated: task.is_auto_generated,
        bundleId: task.bundle_id,
        createdDate: task.created_at,
        lastModified: task.updated_at,
      } as unknown as Task;
    } catch (error) {
      console.error('Failed to get task:', error);
      throw error;
    }
  }
}

export const tasksService = new TasksService();
