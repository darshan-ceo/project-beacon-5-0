import { Task } from '@/contexts/AppStateContext';

export interface CreateTaskData {
  title: string;
  description: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  status: 'Not Started' | 'In Progress' | 'Review' | 'Completed' | 'Overdue';
  assignedToId: string;
  assignedToName: string;
  assignedById: string;
  assignedByName: string;
  dueDate: string;
  estimatedHours: number;
  tags?: string[];
}

export interface UpdateTaskData extends Partial<CreateTaskData> {
  id: string;
}

class TasksService {
  private tasks: Task[] = [];

  async create(userId: string, data: CreateTaskData): Promise<Task> {
    // PHASE 3A: RBAC Permission Check
    const { policyEngine, secureDataAccess } = await import('@/security/policyEngine');
    
    // Validate write permission
    const canCreate = await policyEngine.evaluatePermission(userId, 'tasks', 'write');
    if (!canCreate.allowed) {
      throw new Error('Permission denied: Cannot create tasks');
    }
    
    // Validate case access (ensure user can create tasks for this case)
    const { storageManager } = await import('@/data/StorageManager');
    const storage = storageManager.getStorage();
    const caseData = await storage.getById('cases', data.caseId);
    
    if (!caseData) {
      throw new Error('Case not found');
    }
    
    // Verify case access with scope
    const caseAccess = await secureDataAccess.secureGet(
      userId,
      'cases',
      data.caseId,
      async (id) => caseData
    );
    
    if (!caseAccess) {
      throw new Error('Access denied: Cannot create tasks for this case');
    }
    
    // FIXED: Use UUID instead of timestamp
    const { generateId } = await import('@/data/db');
    const newTask: Task = {
      id: generateId(),
      ...data,
      createdDate: new Date().toISOString().split('T')[0],
      isAutoGenerated: false,
      escalationLevel: 0,
      timezone: 'Asia/Kolkata',
      dueDateValidated: true,
      audit_trail: {
        created_by: userId,
        created_at: new Date().toISOString(),
        updated_by: userId,
        updated_at: new Date().toISOString(),
        change_log: []
      }
    };

    // FIXED: Persist to storage
    const { changeTracker } = await import('./changeTracker');
    const { ENTITY_TYPES } = await import('@/constants/StorageKeys');
    
    try {
      const storage = storageManager.getStorage();
      await storage.create('tasks', {
        id: newTask.id,
        case_id: newTask.caseId,
        assigned_to: newTask.assignedToId,
        due_date: newTask.dueDate ? new Date(newTask.dueDate) : undefined,
        status: newTask.status,
        priority: newTask.priority,
        title: newTask.title,
        description: newTask.description,
        created_at: new Date(),
        updated_at: new Date(),
        is_auto_generated: newTask.isAutoGenerated,
        estimated_hours: newTask.estimatedHours,
      });

      changeTracker.markDirty(ENTITY_TYPES.TASK, newTask.id, 'create');
      changeTracker.logChange(ENTITY_TYPES.TASK, newTask.id, 'create');
    } catch (storageError) {
      console.error('Failed to persist task to storage:', storageError);
    }

    this.tasks.push(newTask);
    return newTask;
  }

  async update(data: UpdateTaskData): Promise<Task> {
    const index = this.tasks.findIndex(t => t.id === data.id);
    if (index === -1) {
      throw new Error('Task not found');
    }

    const updatedTask = {
      ...this.tasks[index],
      ...data
    };

    // Persist to storage
    const { storageManager } = await import('@/data/StorageManager');
    const { changeTracker } = await import('./changeTracker');
    const { ENTITY_TYPES } = await import('@/constants/StorageKeys');
    
    try {
      const storage = storageManager.getStorage();
      await storage.update('tasks', data.id, {
        ...data,
        case_id: data.caseId,
        assigned_to: data.assignedToId,
        due_date: data.dueDate ? new Date(data.dueDate) : undefined,
        status: data.status,
        priority: data.priority,
        title: data.title,
        description: data.description,
        updated_at: new Date(),
      });
      changeTracker.markDirty(ENTITY_TYPES.TASK, data.id, 'update');
      changeTracker.logChange(ENTITY_TYPES.TASK, data.id, 'update');
    } catch (storageError) {
      console.error('Failed to update task in storage:', storageError);
    }

    this.tasks[index] = updatedTask;
    return updatedTask;
  }

  async updateStatus(id: string, status: Task['status']): Promise<Task> {
    return this.update({ id, status });
  }

  async get(id: string): Promise<Task | null> {
    return this.tasks.find(t => t.id === id) || null;
  }

  async delete(id: string): Promise<void> {
    // Persist to storage
    const { storageManager } = await import('@/data/StorageManager');
    const { changeTracker } = await import('./changeTracker');
    const { ENTITY_TYPES } = await import('@/constants/StorageKeys');
    
    try {
      const storage = storageManager.getStorage();
      await storage.delete('tasks', id);
      changeTracker.markDirty(ENTITY_TYPES.TASK, id, 'delete');
      changeTracker.logChange(ENTITY_TYPES.TASK, id, 'delete');
    } catch (storageError) {
      console.error('Failed to delete task from storage:', storageError);
      throw storageError;
    }

    const index = this.tasks.findIndex(t => t.id === id);
    if (index !== -1) {
      this.tasks.splice(index, 1);
    }
  }

  async list(userId: string): Promise<Task[]> {
    // PHASE 3A: Apply scope filtering
    const { secureDataAccess } = await import('@/security/policyEngine');
    
    return secureDataAccess.secureList(
      userId,
      'tasks',
      async () => [...this.tasks]
    );
  }

  async getByCase(userId: string, caseId: string): Promise<Task[]> {
    // PHASE 3A: Validate case access with scope
    const { secureDataAccess } = await import('@/security/policyEngine');
    const { storageManager: sm } = await import('@/data/StorageManager');
    
    const storage = sm.getStorage();
    const caseData = await storage.getById('cases', caseId);
    
    if (!caseData) {
      throw new Error('Case not found');
    }
    
    // Verify case access
    const caseAccess = await secureDataAccess.secureGet(
      userId,
      'cases',
      caseId,
      async (id) => caseData
    );
    
    if (!caseAccess) {
      return []; // No access to case = no tasks
    }
    
    // Return filtered tasks
    return secureDataAccess.secureList(
      userId,
      'tasks',
      async () => this.tasks.filter(t => t.caseId === caseId)
    );
  }

  async getByAssignee(userId: string, assignedToId: string): Promise<Task[]> {
    // PHASE 3A: Apply scope filtering
    const { secureDataAccess } = await import('@/security/policyEngine');
    
    return secureDataAccess.secureList(
      userId,
      'tasks',
      async () => this.tasks.filter(t => t.assignedToId === assignedToId)
    );
  }
}

export const tasksService = new TasksService();