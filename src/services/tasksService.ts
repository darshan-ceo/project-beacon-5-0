import { Task } from '@/contexts/AppStateContext';
import { storageManager } from '@/data/StorageManager';
import { toast } from '@/hooks/use-toast';

export interface CreateTaskData {
  title: string;
  description: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  status: 'Not Started' | 'In Progress' | 'Review' | 'Completed' | 'Overdue';
  assignedToId: string;
  assignedToName: string;
  assignedById?: string;
  assignedByName?: string;
  dueDate: string;
  estimatedHours: number;
  tags?: string[];
}

export interface UpdateTaskData extends Partial<CreateTaskData> {
  id: string;
}

class TasksService {
  /**
   * Create a new task with persistence and dispatch
   */
  async create(taskData: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();
      
      // Build complete task object
      const newTask: Task = {
        id: '', // Server will generate UUID
        title: taskData.title || '',
        description: taskData.description || '',
        caseId: taskData.caseId || '',
        clientId: taskData.clientId || '',
        caseNumber: taskData.caseNumber || '',
        stage: taskData.stage || '',
        priority: taskData.priority || 'Medium',
        status: taskData.status || 'Not Started',
        assignedToId: taskData.assignedToId || '',
        assignedToName: taskData.assignedToName || '',
        assignedById: taskData.assignedById || '',
        assignedByName: taskData.assignedByName || '',
        createdDate: new Date().toISOString().split('T')[0],
        dueDate: taskData.dueDate || '',
        estimatedHours: taskData.estimatedHours || 8,
        isAutoGenerated: (taskData as any).isAutoGenerated ?? false,
        bundleId: (taskData as any).bundleId || undefined,
        escalationLevel: 0,
        timezone: 'Asia/Kolkata',
        dueDateValidated: true,
        audit_trail: {
          created_by: 'system',
          created_at: new Date().toISOString(),
          updated_by: 'system',
          updated_at: new Date().toISOString(),
          change_log: []
        }
      };

      // Persist to Supabase
      const created = await storage.create('tasks', {
        title: newTask.title,
        description: newTask.description,
        case_id: newTask.caseId,
        client_id: newTask.clientId,
        case_number: newTask.caseNumber,
        stage: newTask.stage,
        priority: newTask.priority,
        status: newTask.status,
        assigned_to: newTask.assignedToId,
        due_date: newTask.dueDate,
        estimated_hours: newTask.estimatedHours,
        is_auto_generated: newTask.isAutoGenerated,
        bundle_id: newTask.bundleId || null,
      } as any);

      // Get server-generated UUID
      const persistedTask = { ...newTask, id: created.id };

      // Dispatch to context
      dispatch({ type: 'ADD_TASK', payload: persistedTask });

      // Show success toast
      toast({
        title: "Task Created",
        description: `Task "${persistedTask.title}" has been created successfully.`,
      });

      return persistedTask;
    } catch (error) {
      console.error('Failed to create task:', error);
      toast({
        title: "Error",
        description: "Failed to create task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Update an existing task
   */
  async update(taskId: string, updates: Partial<Task>, dispatch: any): Promise<Task> {
    try {
      const storage = storageManager.getStorage();

      // Persist to Supabase
      await storage.update('tasks', taskId, {
        ...(updates.title && { title: updates.title }),
        ...(updates.description && { description: updates.description }),
        ...(updates.priority && { priority: updates.priority }),
        ...(updates.status && { status: updates.status }),
        ...(updates.assignedToId && { assigned_to: updates.assignedToId }),
        ...(updates.dueDate && { due_date: updates.dueDate }),
        ...(updates.estimatedHours && { estimated_hours: updates.estimatedHours }),
        updated_at: new Date().toISOString(),
      } as any);

      // Build updated task
      const updatedTask = { ...updates, id: taskId } as Task;

      // Dispatch to context
      dispatch({ type: 'UPDATE_TASK', payload: updatedTask });

      // Show success toast
      toast({
        title: "Task Updated",
        description: `Task "${updates.title || taskId}" has been updated successfully.`,
      });

      return updatedTask;
    } catch (error) {
      console.error('Failed to update task:', error);
      toast({
        title: "Error",
        description: "Failed to update task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Delete a task
   */
  async delete(taskId: string, dispatch: any): Promise<void> {
    try {
      const storage = storageManager.getStorage();

      // Delete from Supabase
      await storage.delete('tasks', taskId);

      // Dispatch to context
      dispatch({ type: 'DELETE_TASK', payload: taskId });

      // Show success toast
      toast({
        title: "Task Deleted",
        description: "Task has been deleted successfully.",
      });
    } catch (error) {
      console.error('Failed to delete task:', error);
      toast({
        title: "Error",
        description: "Failed to delete task. Please try again.",
        variant: "destructive"
      });
      throw error;
    }
  }

  /**
   * Bulk update status for multiple tasks
   */
  async bulkUpdateStatus(taskIds: string[], status: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { status: status as any }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update status for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk update priority for multiple tasks
   */
  async bulkUpdatePriority(taskIds: string[], priority: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { priority: priority as any }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update priority for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk reassign tasks to a new employee
   */
  async bulkReassign(taskIds: string[], assigneeId: string, assigneeName: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { assignedToId: assigneeId, assignedToName: assigneeName }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to reassign task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk update due date for multiple tasks
   */
  async bulkUpdateDueDate(taskIds: string[], dueDate: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.update(taskId, { dueDate }, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to update due date for task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk add comment to multiple tasks (stores in description or notes)
   */
  async bulkAddComment(taskIds: string[], comment: string, userName: string, dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;
    const timestamp = new Date().toISOString();
    const formattedComment = `\n\n[${userName} - ${timestamp.split('T')[0]}]: ${comment}`;
    const storage = storageManager.getStorage();

    for (const taskId of taskIds) {
      try {
        const task = await storage.getById('tasks', taskId) as any;
        if (task) {
          const newDescription = (task.description || '') + formattedComment;
          await this.update(taskId, { description: newDescription }, dispatch);
          success++;
        } else {
          failed++;
        }
      } catch (error) {
        console.error(`Failed to add comment to task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Bulk delete multiple tasks
   */
  async bulkDelete(taskIds: string[], dispatch: any): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;

    for (const taskId of taskIds) {
      try {
        await this.delete(taskId, dispatch);
        success++;
      } catch (error) {
        console.error(`Failed to delete task ${taskId}:`, error);
        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * List all tasks from Supabase
   */
  async list(): Promise<Task[]> {
    try {
      const storage = storageManager.getStorage();
      const tasks = await storage.getAll('tasks');
      
      // Basic mapping - display-only fields will be populated by UI layer
      return tasks.map((t: any) => ({
        id: t.id,
        title: t.title,
        description: t.description,
        status: t.status,
        priority: t.priority,
        caseId: t.case_id,
        clientId: t.client_id,
        assignedToId: t.assigned_to,
        assignedById: t.assigned_by,
        dueDate: t.due_date,
        completedDate: t.completed_at,
        estimatedHours: t.estimated_hours,
        actualHours: t.actual_hours,
        stage: t.stage,
        isAutoGenerated: t.is_auto_generated,
        bundleId: t.bundle_id,
        createdDate: t.created_at,
        lastModified: t.updated_at,
      } as unknown as Task));
    } catch (error) {
      console.error('Failed to get task:', error);
      throw error;
    }
  }
}

export const tasksService = new TasksService();
