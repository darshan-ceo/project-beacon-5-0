/**
 * Task Creation Service
 * Unified task creation logic for both templates and bundles
 */

import { tasksService, CreateTaskData } from './tasksService';
import { persistenceService } from './persistenceService';
import { GSTStage } from '../../config/appConfig';
import type { AppAction, Task } from '@/contexts/AppStateContext';

export interface TaskCreationRequest {
  title: string;
  description?: string;
  caseId: string;
  clientId: string;
  caseNumber: string;
  stage: GSTStage;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  assignedToId: string;
  assignedToName: string;
  estimatedHours: number;
  source: 'template' | 'bundle' | 'manual';
  sourceId?: string;
  sourceName?: string;
}

interface TaskCreationResult {
  task: Task;
  persisted: boolean;
  addedToState: boolean;
}

class TaskCreationService {
  async createTask(
    request: TaskCreationRequest,
    dispatch?: React.Dispatch<AppAction>
  ): Promise<TaskCreationResult> {
    try {
      // Create the task using the tasks service
      const task = await tasksService.create({
        title: request.title,
        description: this.buildDescription(request),
        caseId: request.caseId,
        clientId: request.clientId,
        caseNumber: request.caseNumber,
        stage: request.stage,
        priority: request.priority,
        status: 'Not Started',
        assignedToId: request.assignedToId,
        assignedToName: request.assignedToName,
        assignedById: 'system',
        assignedByName: this.getAssignedByName(request.source),
        dueDate: this.calculateDueDate(request.estimatedHours),
        estimatedHours: request.estimatedHours
      } as CreateTaskData);

      // Add automation metadata
      const finalTask = {
        ...task,
        isAutoGenerated: request.source !== 'manual',
        source: request.source,
        sourceId: request.sourceId,
        sourceName: request.sourceName
      } as Task;

      // Persist to IndexedDB
      let persisted = false;
      try {
        await persistenceService.create('tasks', finalTask);
        persisted = true;
      } catch (e) {
        console.warn('[TaskCreation] Failed to persist task to IndexedDB, continuing', e);
      }

      // Update app state
      let addedToState = false;
      if (dispatch) {
        dispatch({ type: 'ADD_TASK', payload: finalTask });
        addedToState = true;
      }

      return {
        task: finalTask,
        persisted,
        addedToState
      };
      
    } catch (error) {
      console.error(`[TaskCreation] Failed to create task ${request.title}:`, error);
      throw error;
    }
  }

  async createMultipleTasks(
    requests: TaskCreationRequest[],
    dispatch?: React.Dispatch<AppAction>
  ): Promise<TaskCreationResult[]> {
    const results: TaskCreationResult[] = [];
    
    for (const request of requests) {
      try {
        const result = await this.createTask(request, dispatch);
        results.push(result);
      } catch (error) {
        console.error(`[TaskCreation] Failed to create task ${request.title}:`, error);
        // Continue with other tasks
      }
    }
    
    return results;
  }

  private buildDescription(request: TaskCreationRequest): string {
    let description = request.description || '';
    
    const sourceInfo = this.getSourceInfo(request);
    if (sourceInfo) {
      description += description ? '\n\n' : '';
      description += sourceInfo;
    }
    
    return description;
  }

  private getSourceInfo(request: TaskCreationRequest): string {
    switch (request.source) {
      case 'template':
        return `[Auto-created from template: ${request.sourceName || 'Unknown'}]`;
      case 'bundle':
        return `[Auto-created from bundle: ${request.sourceName || 'Unknown'}]`;
      case 'manual':
      default:
        return '';
    }
  }

  private getAssignedByName(source: string): string {
    switch (source) {
      case 'template':
        return 'Template Automation';
      case 'bundle':
        return 'Bundle Automation';
      case 'manual':
      default:
        return 'Manual Assignment';
    }
  }

  private calculateDueDate(estimatedHours: number): string {
    const workDaysToAdd = Math.ceil(estimatedHours / 8);
    const dueDate = new Date();
    
    let addedDays = 0;
    while (addedDays < workDaysToAdd) {
      dueDate.setDate(dueDate.getDate() + 1);
      if (dueDate.getDay() !== 0 && dueDate.getDay() !== 6) {
        addedDays++;
      }
    }
    
    return dueDate.toISOString().split('T')[0];
  }

  // Get automation analytics
  getAutomationStats(tasks: Task[]): {
    total: number;
    bySource: Record<string, number>;
    automated: number;
    manual: number;
  } {
    const bySource: Record<string, number> = {};
    let automated = 0;
    let manual = 0;

    tasks.forEach(task => {
      const source = (task as any).source || 'manual';
      bySource[source] = (bySource[source] || 0) + 1;
      
      if ((task as any).isAutoGenerated) {
        automated++;
      } else {
        manual++;
      }
    });

    return {
      total: tasks.length,
      bySource,
      automated,
      manual
    };
  }
}

export const taskCreationService = new TaskCreationService();