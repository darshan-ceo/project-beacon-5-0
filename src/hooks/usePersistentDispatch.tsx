/**
 * Persistent Dispatch Hook
 * Intercepts dispatch actions and immediately persists changes to Supabase
 * Ensures data integrity and prevents data loss on refresh
 */

import { useCallback } from 'react';
import { AppAction } from '@/contexts/AppStateContext';
import { storageManager } from '@/data/StorageManager';
import { toast } from '@/hooks/use-toast';

type PersistCallback = () => Promise<void>;

export const usePersistentDispatch = (
  originalDispatch: React.Dispatch<AppAction>,
  onPersistSuccess?: PersistCallback
) => {
  
  const persistentDispatch = useCallback(async (action: AppAction) => {
    try {
      // Check if storage is initialized
      let storage;
      try {
        storage = storageManager.getStorage();
      } catch (initError) {
        console.warn('âš ï¸ Storage not initialized, skipping persistence for:', action.type);
        // If storage is not ready, just update local state
        originalDispatch(action);
        return;
      }
      
      console.log(`ðŸ’¾ Persisting action: ${action.type}`);
      
      // Persist to Supabase BEFORE updating local state
      switch (action.type) {
        // Cases
        case 'ADD_CASE':
          await storage.create('cases', action.payload);
          break;
        case 'UPDATE_CASE':
          await storage.update('cases', action.payload.id, action.payload);
          break;
        case 'DELETE_CASE':
          await storage.delete('cases', action.payload);
          break;
          
        // Clients
        case 'ADD_CLIENT':
          await storage.create('clients', action.payload);
          break;
        case 'UPDATE_CLIENT':
          await storage.update('clients', action.payload.id, action.payload);
          break;
        case 'DELETE_CLIENT':
          await storage.delete('clients', action.payload);
          break;
          
        // Tasks - Transform camelCase to snake_case for database
        case 'ADD_TASK': {
          const task = action.payload as any;
          const isValidUUID = (val: any) => typeof val === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val);
          const asUUIDOrNull = (val: any) => (isValidUUID(val) ? val : null);
          
          const taskPayload: any = {
            // Only include id if it's a valid UUID
            ...(isValidUUID(task.id) && { id: task.id }),
            case_id: asUUIDOrNull(task.caseId || task.case_id),
            client_id: asUUIDOrNull(task.clientId || task.client_id),
            case_number: task.caseNumber || task.case_number || null,
            title: task.title,
            description: task.description || '',
            stage: task.stage,
            priority: task.priority,
            status: task.status,
            assigned_to: asUUIDOrNull(task.assignedToId || task.assigned_to),
            assigned_to_name: task.assignedToName || task.assigned_to_name || '',
            assigned_by: asUUIDOrNull(task.assignedById || task.assigned_by),
            assigned_by_name: task.assignedByName || task.assigned_by_name || '',
            due_date: task.dueDate || task.due_date,
            estimated_hours: task.estimatedHours || task.estimated_hours || 0,
            actual_hours: task.actualHours || task.actual_hours || 0,
            is_auto_generated: task.isAutoGenerated ?? task.is_auto_generated ?? false,
            escalation_level: task.escalationLevel ?? task.escalation_level ?? 0,
            timezone: task.timezone || 'Asia/Kolkata',
            due_date_validated: task.dueDateValidated ?? task.due_date_validated ?? true,
            tags: task.tags || [],
            hearing_id: asUUIDOrNull(task.hearingId || task.hearing_id),
            created_at: task.createdDate || new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };
          
          await storage.create('tasks', taskPayload);
          break;
        }
        case 'UPDATE_TASK': {
          const task = action.payload as any;
          const isValidUUID = (val: any) => typeof val === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val);
          const asUUIDOrNull = (val: any) => (isValidUUID(val) ? val : null);
          
          const updatePayload: any = {
            id: task.id,
            case_id: asUUIDOrNull(task.caseId || task.case_id),
            client_id: asUUIDOrNull(task.clientId || task.client_id),
            case_number: task.caseNumber || task.case_number || null,
            title: task.title,
            description: task.description || '',
            stage: task.stage,
            priority: task.priority,
            status: task.status,
            assigned_to: asUUIDOrNull(task.assignedToId || task.assigned_to),
            assigned_to_name: task.assignedToName || task.assigned_to_name || '',
            assigned_by: asUUIDOrNull(task.assignedById || task.assigned_by),
            assigned_by_name: task.assignedByName || task.assigned_by_name || '',
            due_date: task.dueDate || task.due_date,
            estimated_hours: task.estimatedHours ?? task.estimated_hours ?? 0,
            actual_hours: task.actualHours ?? task.actual_hours ?? 0,
            is_auto_generated: task.isAutoGenerated ?? task.is_auto_generated ?? false,
            escalation_level: task.escalationLevel ?? task.escalation_level ?? 0,
            timezone: task.timezone || 'Asia/Kolkata',
            due_date_validated: task.dueDateValidated ?? task.due_date_validated ?? true,
            tags: task.tags || [],
            hearing_id: asUUIDOrNull(task.hearingId || task.hearing_id),
            updated_at: new Date().toISOString(),
          };
          
          await storage.update('tasks', task.id, updatePayload);
          break;
        }
        case 'DELETE_TASK':
          await storage.delete('tasks', action.payload);
          break;
          
        // Hearings
        case 'ADD_HEARING':
          await storage.create('hearings', action.payload);
          break;
        case 'UPDATE_HEARING':
          await storage.update('hearings', action.payload.id, action.payload);
          break;
        case 'DELETE_HEARING':
          await storage.delete('hearings', action.payload);
          break;
          
        // Employees
        case 'ADD_EMPLOYEE':
          await storage.create('employees', action.payload);
          break;
        case 'UPDATE_EMPLOYEE':
          await storage.update('employees', action.payload.id, action.payload);
          break;
        case 'DELETE_EMPLOYEE':
          await storage.delete('employees', action.payload);
          break;
          
        // Documents
        case 'ADD_DOCUMENT':
          // Documents are persisted by supabaseDocumentService before dispatch
          // Skip re-persistence to avoid duplicate insertion
          console.log('â­ï¸ Skipping ADD_DOCUMENT persistence (already persisted by upload service)');
          break;
        case 'UPDATE_DOCUMENT':
          await storage.update('documents', action.payload.id, action.payload);
          break;
        case 'DELETE_DOCUMENT':
          await storage.delete('documents', action.payload);
          break;
          
        // Courts
        case 'ADD_COURT':
          await storage.create('courts', action.payload);
          break;
        case 'UPDATE_COURT':
          await storage.update('courts', action.payload.id, action.payload);
          break;
        case 'DELETE_COURT':
          await storage.delete('courts', action.payload);
          break;
          
        // Judges
        case 'ADD_JUDGE': {
          const isValidUUID = (v: any) => typeof v === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v);
          const payload = { ...action.payload } as any;
          // Remove client-generated id if it's not a valid UUID
          if (!isValidUUID(payload.id)) {
            delete payload.id;
          }
          // Persist to backend and get the UUID back
          const saved = await storage.create('judges', payload);
          // Dispatch with the database-generated UUID to keep UI state consistent
          originalDispatch({ type: 'ADD_JUDGE', payload: { ...action.payload, id: (saved as any).id } as any });
          
          // Call success callback if provided
          if (onPersistSuccess) {
            await onPersistSuccess();
          }
          return; // Prevent the generic dispatch below from firing
        }
        case 'UPDATE_JUDGE':
          await storage.update('judges', action.payload.id, action.payload);
          break;
        case 'DELETE_JUDGE':
          await storage.delete('judges', action.payload);
          break;
          
        // Client Groups
        case 'ADD_CLIENT_GROUP':
          await storage.create('client_groups', action.payload);
          break;
        case 'UPDATE_CLIENT_GROUP':
          await storage.update('client_groups', action.payload.id, action.payload);
          break;
        case 'DELETE_CLIENT_GROUP':
          await storage.delete('client_groups', action.payload);
          break;
          
        // Folders
        case 'ADD_FOLDER':
          await storage.create('folders', action.payload);
          break;
        case 'UPDATE_FOLDER':
          await storage.update('folders', action.payload.id, action.payload);
          break;
        case 'DELETE_FOLDER':
          await storage.delete('folders', action.payload);
          break;
          
        // For other actions that don't need immediate persistence
        default:
          // No persistence needed for these actions (e.g., UI state changes)
          break;
      }
      
      // After successful persistence, update local state
      originalDispatch(action);
      
      // Call success callback if provided
      if (onPersistSuccess) {
        await onPersistSuccess();
      }
      
    } catch (error) {
      console.error('âŒ Persistence failed for action:', action.type, error);
      
      // Show user-friendly error message
      const errorMessage = error?.message || 'Unknown error';
      
      // Don't show error toasts for non-critical UI actions
      const criticalActions = ['ADD_', 'UPDATE_', 'DELETE_'];
      const isCriticalAction = criticalActions.some(prefix => action.type.startsWith(prefix));
      
      if (isCriticalAction) {
        toast({
          title: "Failed to save changes",
          description: `${errorMessage}. Please try again or contact support if the problem persists.`,
          variant: "destructive"
        });
      }
      
      // Don't update local state if persistence failed
      // This ensures UI stays consistent with database
      throw error;
    }
  }, [originalDispatch, onPersistSuccess]);
  
  return persistentDispatch;
};

/**
 * Synchronous version that wraps async dispatch for compatibility
 * Use this when you need a synchronous dispatch signature
 */
export const useSyncPersistentDispatch = (
  originalDispatch: React.Dispatch<AppAction>,
  onPersistSuccess?: PersistCallback
): React.Dispatch<AppAction> => {
  const persistentDispatch = usePersistentDispatch(originalDispatch, onPersistSuccess);
  
  return useCallback((action: AppAction) => {
    // Fire and forget - async operations happen in background
    persistentDispatch(action).catch(error => {
      console.error('Background persistence failed:', error);
    });
  }, [persistentDispatch]);
};
