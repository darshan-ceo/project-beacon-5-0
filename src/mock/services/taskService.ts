/**
 * Task Service - DEMO mode implementation with write-through pattern
 */

import { unifiedStore } from '@/persistence/unifiedStore';
import type { Task } from '@/contexts/AppStateContext';
import type { 
  TaskService, 
  CreateTaskData, 
  UpdateTaskData, 
  ApiResponse 
} from '@/mock/apiContracts';
import { demoConfig } from '@/config/demoConfig';

class TaskServiceImpl implements TaskService {
  async create(data: CreateTaskData): Promise<ApiResponse<Task>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();
      
      // Auto-populate derived fields
      const caseData = await unifiedStore.cases.getById(data.caseId);
      if (!caseData) {
        throw new Error('Case not found');
      }

      const newTask: Task = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        ...data,
        clientId: caseData.clientId,
        caseNumber: caseData.caseNumber,
        status: 'Not Started',
        createdDate: new Date().toISOString(),
        escalationLevel: 0,
        isAutoGenerated: data.isAutoGenerated || false
      };

      // Write-through pattern: UnifiedStore -> AppState (via dispatch)
      await unifiedStore.tasks.create(newTask);

      return {
        success: true,
        data: newTask,
        message: 'Task created successfully'
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Create Task');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async update(id: string, data: UpdateTaskData): Promise<ApiResponse<Task>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const updates: Partial<Task> = {
        ...data
      };

      // Set completion date if status is completed
      if (data.status === 'Completed' && !updates.completedDate) {
        updates.completedDate = new Date().toISOString();
      }

      const updatedTask = await unifiedStore.tasks.update(id, updates);

      return {
        success: true,
        data: updatedTask,
        message: 'Task updated successfully'
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Update Task');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async delete(id: string): Promise<ApiResponse<void>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      await unifiedStore.tasks.delete(id);

      return {
        success: true,
        message: 'Task deleted successfully'
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Delete Task');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async getById(id: string): Promise<ApiResponse<Task>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const task = await unifiedStore.tasks.getById(id);
      if (!task) {
        return {
          success: false,
          error: 'Task not found'
        };
      }

      return {
        success: true,
        data: task
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Get Task');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async getAll(): Promise<ApiResponse<Task[]>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const tasks = await unifiedStore.tasks.getAll();

      return {
        success: true,
        data: tasks
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Get All Tasks');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async getByCase(caseId: string): Promise<ApiResponse<Task[]>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const tasks = await unifiedStore.tasks.query((task) => task.caseId === caseId);

      return {
        success: true,
        data: tasks
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Get Tasks by Case');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async getByAssignee(assigneeId: string): Promise<ApiResponse<Task[]>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const tasks = await unifiedStore.tasks.query((task) => task.assignedToId === assigneeId);

      return {
        success: true,
        data: tasks
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Get Tasks by Assignee');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }

  async bulkCreate(tasks: CreateTaskData[]): Promise<ApiResponse<Task[]>> {
    try {
      demoConfig.assertDemoMode();
      await demoConfig.simulateDelay();

      const createdTasks: Task[] = [];

      for (const taskData of tasks) {
        // Auto-populate derived fields
        const caseData = await unifiedStore.cases.getById(taskData.caseId);
        if (!caseData) {
          console.warn(`Case ${taskData.caseId} not found for task ${taskData.title}`);
          continue;
        }

        const newTask: Task = {
          id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          ...taskData,
          clientId: caseData.clientId,
          caseNumber: caseData.caseNumber,
          status: 'Not Started',
          createdDate: new Date().toISOString(),
          escalationLevel: 0,
          isAutoGenerated: taskData.isAutoGenerated || false
        };

        createdTasks.push(newTask);
      }

      // Bulk create in unifiedStore
      const results = await unifiedStore.bulkCreate('tasks', createdTasks);

      return {
        success: true,
        data: results,
        message: `${results.length} tasks created successfully`
      };
    } catch (error) {
      demoConfig.handleError(error as Error, 'Bulk Create Tasks');
      return {
        success: false,
        error: (error as Error).message
      };
    }
  }
}

export const taskService = new TaskServiceImpl();